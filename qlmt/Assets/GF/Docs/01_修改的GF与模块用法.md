# 你修改的 GF 模块用法（仅 Assets/GF 差异版）

更新时间：2026-02-27  
范围限制：只描述 `qlmt/Assets/GF` 下你新增/修改、且与官方 GF 不同的部分。

## 1. 差异总览

当前识别到的 GF 差异点：

1. 新增预制体：`qlmt/Assets/GF/MyGameFramework.prefab`  
2. 资源模式扩展：`qlmt/Assets/GF/GameFramework/Resource/ResourceMode.cs`  
3. 资源管理器适配：`qlmt/Assets/GF/GameFramework/Resource/ResourceManager.cs`  
4. 资源加载器适配：`qlmt/Assets/GF/GameFramework/Resource/ResourceManager.ResourceLoader.cs`  
5. 接口层同步：`qlmt/Assets/GF/GameFramework/Resource/IResourceManager.cs`  
6. Runtime 组件适配：`qlmt/Assets/GF/Scripts/Runtime/Resource/ResourceComponent.cs`  
7. 新增代理：`qlmt/Assets/GF/Scripts/Runtime/Resource/ResourcesLoadResourceAgentHelper.cs`  
8. 编辑器资源组件适配：`qlmt/Assets/GF/Scripts/Runtime/Resource/EditorResourceComponent.cs`  
9. Inspector 适配：`qlmt/Assets/GF/Scripts/Editor/Inspector/ResourceComponentInspector.cs`

核心方向只有一条：**在官方 AB/可更新资源链路之外，补一套可直接走 Unity `Resources` 的后端模式（`ResourceMode.Resource`）**。

## 2. 你新增的模式：`ResourceMode.Resource`

文件：`qlmt/Assets/GF/GameFramework/Resource/ResourceMode.cs`

你新增了枚举值：

```csharp
Resource = 4
```

作用：

1. 给资源系统增加“Resources 直载模式”开关。  
2. 让 Runtime 和内核在同一模式标识下分支处理。  

使用方式：

1. 在 `ResourceComponent` 上把 `m_ResourceMode` 配到 `Resource`。  
2. 启动后资源系统走你加的 Resources 分支，而非版本表/更新流程分支。  

## 3. `ResourceManager` 的差异行为

文件：`qlmt/Assets/GF/GameFramework/Resource/ResourceManager.cs`

### 3.1 `SetResourceMode` 新分支

你在 `SetResourceMode(...)` 里加入了 `ResourceMode.Resource` 分支，并明确注释：

- Resources 模式不依赖版本列表、校验与更新流程。

结果：

1. 不创建 `VersionListProcessor/ResourceChecker/ResourceUpdater`。  
2. 资源初始化流程变轻，适合本地开发或轻量项目。  

### 3.2 `InitResources` 行为变化

你让 `ResourceMode.Resource` 下 `InitResources(...)` 直接完成回调并返回，不走包体版本初始化。  

结果：

1. 省去资源清单初始化链。  
2. 业务启动不再依赖版本表可用性。  

### 3.3 Update/Apply/Check 相关流程隔离

由于上述模块未创建，Resources 模式天然不走更新链路。  

注意：

1. 在此模式下调用“可更新模式专用 API”会触发不支持或条件不满足。  
2. 这是设计上的“能力裁剪”，不是 bug。  

## 4. `ResourceLoader` 的差异行为

文件：`qlmt/Assets/GF/GameFramework/Resource/ResourceManager.ResourceLoader.cs`

### 4.1 `HasAsset` 改为宽松判定

你在 `ResourceMode.Resource` 下不依赖 `AssetInfo/ResourceInfo` 资源表，改为：

1. 资源名非空则按“磁盘资源可尝试加载”返回。  
2. 真正存在性由后续 `Resources.LoadAsync` 成功与否决定。  

### 4.2 `CheckAsset` 跳过资源表校验

你在 Resources 模式中：

1. 直接构造占位 `ResourceInfo`。  
2. 依赖数组设为空（不走依赖资源表）。  

这解决了官方流程中“必须先有资产-资源映射表”才能加载的问题。

### 4.3 Resources 后端占位 `ResourceInfo`

你新增 `CreateResourcesBackendResourceInfo(...)`，让加载任务能复用现有 Task/Agent 管线。  

结果：

1. 不需要重写整套加载任务系统。  
2. 只在资源信息入口做“兼容占位”。  

## 5. `ResourceComponent` 的差异行为

文件：`qlmt/Assets/GF/Scripts/Runtime/Resource/ResourceComponent.cs`

### 5.1 `SetResourceMode(Resource)` 支持

你在 `SetResourceMode` 里保留了 `ResourceMode.Resource` 分支（不注册版本序列化器回调）。  

结果：

1. Resources 模式启动不会触发版本序列化器依赖。  
2. 避免空引用或模式不一致问题。  

### 5.2 加载代理切换逻辑

你在 `AddLoadResourceAgentHelper(...)` 里加入：

1. 当模式为 `Resource` 时，强制使用 `ResourcesLoadResourceAgentHelper`。  
2. 忽略自定义 AB 代理，防止模式与代理错配。  

这是当前差异实现里最关键的 Runtime 入口。

## 6. 你新增的 `ResourcesLoadResourceAgentHelper`

文件：`qlmt/Assets/GF/Scripts/Runtime/Resource/ResourcesLoadResourceAgentHelper.cs`

这个类是你这套改造的核心执行器，行为如下：

1. `ReadFile(...)`：返回占位资源对象，保持与原管线事件契约兼容。  
2. `LoadAsset(...)`：
   - 普通资源：走 `Resources.LoadAsync(...)`
   - 场景资源：走 `SceneManager.LoadSceneAsync(..., Additive)`
3. `ReadBytes/ParseBytes`：明确报错“不支持二进制资源”。  
4. `Update()`：推进异步进度并触发成功/失败事件。  
5. `Reset()`：清理当前请求状态。

使用边界：

1. 只适用于 `ResourceMode.Resource`。  
2. 资源路径必须符合 `Resources` 约定（相对路径，不带扩展名）。  
3. 不支持走文件系统二进制读取和版本包流程。  

## 7. `EditorResourceComponent` 差异点

文件：`qlmt/Assets/GF/Scripts/Runtime/Resource/EditorResourceComponent.cs`

你保持了编辑器资源模式下的接口行为与 Runtime 资源模式隔离：

1. `SetResourceMode(...)` 等方法在编辑器组件里仍 `NotSupportedException`。  
2. 通过 `BaseComponent.EditorResourceMode` 决定是否接管 `EditorResourceHelper`。  

作用：

1. 避免把运行时 `ResourceMode.Resource` 逻辑误混到 `EditorResourceComponent`。  
2. 保持编辑器模拟加载与运行时模式边界清晰。  

## 8. `ResourceComponentInspector` 差异点

文件：`qlmt/Assets/GF/Scripts/Editor/Inspector/ResourceComponentInspector.cs`

你这里的改动目标是让新模式在 Inspector 里可见、可配、可读状态：

1. 读取 `m_EditorResourceMode` 控制可编辑项启停。  
2. 兼容新增模式下的状态显示（避免把 N/A/统计显示写死到旧模式）。  

## 9. `MyGameFramework.prefab` 的差异配置用法

文件：`qlmt/Assets/GF/MyGameFramework.prefab`

这是你在官方 `GameFramework.prefab` 基础上的项目化配置副本，当前关键差异：

1. 资源模式配置为 `Resource`。  
2. 使用 `Resources` 后端参数。  
3. 配置了项目自己的流程入口、UI 组、Entity 组参数。  

实际用法：

1. 场景挂这个预制体（或把其配置同步到场景内 GF 实例）。  
2. 保证资源路径组织与 `Resources` 模式一致。  

## 10. 这套改造的结论

你对 GF 的实质改造是：  
**在官方资源系统上新增并打通 `Resources` 后端运行模式，使项目可绕开资源清单/更新链，直接使用 `Resources.LoadAsync` 管线，同时复用 GF 的任务与事件框架。**

如果后续要继续扩展，只建议围绕以下三点：

1. 补充 `ResourceMode.Resource` 下的能力边界文档（哪些 API 可用/不可用）。  
2. 给 `ResourcesLoadResourceAgentHelper` 增加更细的错误分类和统计。  
3. 在 Inspector 中明确标注“当前模式为 Resources，更新链路不可用”。
