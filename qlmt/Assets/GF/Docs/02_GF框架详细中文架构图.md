# GF 框架详细中文架构图（项目实装版）

更新时间：2026-02-27  
适用工程：`qlmt`

## 1. 分层总览图（项目当前形态）

```mermaid
flowchart TB
    A[业务层: Assets/_Game] --> B[Unity 运行时封装层: Assets/GF/Scripts/Runtime]
    C[编辑器工具层: Assets/GF/Scripts/Editor] --> B
    B --> D[GF 内核层: Assets/GF/GameFramework]

    subgraph 业务层
      A1[GameEntry partial 门面]
      A2[Procedure: Load/Main/Combat]
      A3[UIFormLogic: LoadUI/MainUI]
      A4[自定义组件: EntityIdPoolComponent]
    end

    subgraph Runtime封装层
      B1[BaseComponent]
      B2[ProcedureComponent]
      B3[UIComponent]
      B4[ResourceComponent]
      B5[EventComponent]
      B6[EntityComponent]
    end

    subgraph 内核层
      D1[GameFrameworkEntry]
      D2[ProcedureManager]
      D3[UIManager]
      D4[ResourceManager]
      D5[EventManager]
      D6[EntityManager]
    end

    A1 --> B2
    A1 --> B3
    A1 --> B5
    A1 --> B6
    B1 --> D1
    B2 --> D2
    B3 --> D3
    B4 --> D4
    B5 --> D5
    B6 --> D6
```

## 2. 程序集依赖图（asmdef）

```mermaid
flowchart LR
    G[GameFramework] --> R[UnityGameFramework.Runtime]
    G --> E[UnityGameFramework.Editor]
    R --> E
    M[_Game 业务程序集/脚本] --> R
```

说明：

1. `GameFramework` 是纯内核，不直接写业务逻辑。  
2. `UnityGameFramework.Runtime` 是 Unity 组件化封装。  
3. `_Game` 业务层通过 Runtime 暴露接口接入。  

## 3. 启动时序图（当前场景）

```mermaid
sequenceDiagram
    participant U as Unity Scene
    participant GC as GameFrameworkComponent
    participant GE as UnityGF.GameEntry
    participant BC as BaseComponent
    participant GFE as GameFrameworkEntry
    participant PC as ProcedureComponent
    participant BIZ as _Game.GameEntry
    participant LP as LoadProcedure

    U->>GC: Awake()
    GC->>GE: RegisterComponent(this)
    U->>BC: Update()
    BC->>GFE: Update(elapse, realElapse)
    U->>PC: Start()
    PC->>PC: 反射创建流程实例
    PC->>PC: StartProcedure(LoadProcedure)
    U->>BIZ: Start()
    BIZ->>GE: GetComponent<T>() 缓存到静态门面
    PC->>LP: OnEnter()
    LP->>BIZ: GameEntry.UI.OpenUIForm(...)
```

## 4. 内核模块创建与更新机制图

```mermaid
flowchart TD
    A[业务调用 GetModule<IxxxManager>] --> B{模块是否已存在}
    B -- 是 --> C[返回现有模块]
    B -- 否 --> D[反射创建 XxxManager]
    D --> E[按 Priority 插入模块链表]
    E --> F[返回新模块]

    G[每帧 BaseComponent.Update] --> H[GameFrameworkEntry.Update]
    H --> I[按优先级轮询每个模块 Update]
```

关键点：

1. 内核模块是惰性创建（第一次 `GetModule` 时创建）。  
2. 更新顺序由模块 `Priority` 决定。  
3. 关闭时按逆序 `Shutdown`，再清理引用池和缓存内存。  

## 5. 你项目当前的运行时对象结构（简化）

```text
SampleScene
├─ Main Camera
├─ Canvas
├─ EventSystem
└─ GameFramework (根)
   ├─ [GF预制体实例节点]
   │  ├─ Base
   │  ├─ Event
   │  ├─ Procedure
   │  ├─ Resource
   │  ├─ UI
   │  ├─ Entity
   │  └─ ...其它内置组件
   └─ Customs
      └─ EntityIdPoolComponent
```

## 6. 你项目当前的业务调用路径图

```mermaid
flowchart LR
    BTN1[LoadUI 按钮点击] --> P1[当前流程 ChangeState<MainProcedure>]
    BTN2[MainUI 按钮点击] --> P2[当前流程 ChangeState<CombatProcedure>]
    P1 --> UI1[MainProcedure.OnEnter 打开 MainUI]
    P2 --> CMB[CombatProcedure 进入战斗逻辑]

    LD[LoadProcedure.OnEnter] --> UI0[打开 LoadUI]
    LE[LoadProcedure.OnLeave] --> UIC0[关闭 LoadUI]
```

## 7. 资源路径与加载模型（当前配置）

```mermaid
flowchart TD
    A[GameAssetPath.GetUI('Load/LoadUIForm')] --> B[生成路径: Prefabs/UI/Load/LoadUIForm]
    B --> C[GameEntry.UI.OpenUIForm]
    C --> D[UIComponent -> IUIManager]
    D --> E[ResourceComponent]
    E --> F[ResourceMode.Resource]
    F --> G[Resources 后端加载代理]
```

当前配置含义：

1. 你已把 `ResourceMode` 设为 `Resource`，适合当前快速迭代阶段。  
2. 业务路径组织必须和 `GameAssetPath` 返回值一致。  
3. 后续切 AB/可更新模式时，主要变更在 Resource 配置与资源构建链路，不需要推翻业务层调用入口。  

## 8. 可扩展点地图（建议按此扩）

1. 新业务系统：
   - 新建 `_Game/Scripts/Modules/XXXComponent` 继承 `GameFrameworkComponent`
   - 在 `GameEntry.CustomComponents.cs` 增加静态入口
2. 新流程：
   - 新建 `ProcedureBase` 子类
   - 加入 `ProcedureComponent` 的可用流程数组
3. 新 UI：
   - 新建 `UIFormLogic` 子类 + Prefab
   - 通过 `GameEntry.UI.OpenUIForm` 统一打开
4. 新事件：
   - 定义 `GameEventArgs` 子类
   - 用 `GameEntry.Event` 订阅/抛出

## 9. 结论

你当前 GF 架构已经稳定在“内核（GameFramework）+ Unity封装（Runtime）+ 业务门面（_Game）”三段式。只要保持业务统一走 `GameEntry` 门面，后续模块扩展和资源模式切换都可控。
